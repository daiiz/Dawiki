<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<dom-module id="dawiki-line">
  <template>
    <style>
      @import url(https://fonts.googleapis.com/earlyaccess/notosansjapanese.css);
      :host {
        font-family: 'Noto Sans Japanese', sans-serif;
        display: block;
        position: relative;
        top: 0;
        width: 100%;
      }

      #line, #editor, #editorShadow {
        position: relative;
        top: 0;
        font-family: 'Noto Sans Japanese', sans-serif;
        color: #555;
        font-size: 15px;
        line-height: 25px;
        padding-left: 4px;
        min-height: 25px;
        display: block;
      }

      #editor, #editorShadow {
        font-family: 'Noto Sans Japanese', sans-serif;
        display: none;
        /* #999などで着色するとデバッグしやすい */
        color: #999;
        color: rgba(0, 0, 0, 0) !important;
        width: 100%;
        border: 0;
        box-sizing: border-box;
        padding: 0;
        margin-left: 4px;
        resize: none;
        caret-color: #555;
      }

      #editorShadow {
        top: 0;
        color: red !important;
        color: #555 !important;
        display: none;
      }

      #editor {
        position: absolute !important;
        top: 0;
        background-color: rgba(0, 0, 0, 0) !important;
      }

      .title {
        font-size: 28px !important;
        line-height: 38px !important;
        margin-bottom: 12px;
      }

      textarea:focus {
        outline: 0;
        overflow: hidden;
      }
    </style>
    <div id="line" on-click="_fireupdateLineHighlight"></div>
    <div id="editorShadow"></div>
    <textarea id="editor" type="text" spellcheck="false" 
      on-keydown="handleKeydown" on-keyup="updateRaw" on-keypress="updateRawEnter"></textarea>
  </template>

  <script src="../../dist/bundle.js"></script>
  <script>
    class DawikiLine extends Polymer.Element {
      static get is () { return 'dawiki-line' }
      static get properties () {
        return {
          raw: {
            type: String, 
            value: '',
            observer: '_rawChanged'
          },
          caret: {
            type: Number,
            value: 0,
            observer: '_caretChanged'
          },
          id     : {type: String, value: ''},
          hash   : {type: String, value: ''},
          istitle: {type: Boolean, value: false},
          /* IMEに矢印キーを乗っ取られているときは矢印機能をロックする */
          arrowLocked: {
            type: Boolean,
            value: false
          },
          /* 行の背景色 */
          bgcolor   : {
            type: String, 
            value: '#fff',
            observer: '_bgcolorChanged'
          },
        }
      }

      ready () {
        super.ready();
        this.$.editor.value = this.raw;
        dawiki.initTextarea(this.$.editor);
        if (JSON.parse(this.istitle)) {
          dawiki.addClass(this.$.line, ['title']);
          dawiki.addClass(this.$.editor, ['title']);
          dawiki.addClass(this.$.editorShadow, ['title']);
        }
      }

      handleKeydown (e) {
        var editor = this.$.editor;
        var txt = editor.value;
        var diff = Math.abs(this.raw - txt);
        var keyCode = e.keyCode;
        // IMEの候補を矢印キーで操作しているときは keyCode=229
        console.info('>>>', keyCode)
        if (keyCode === 229) {
          this.arrowLocked = true;
        }else {
          this.arrowLocked = false;
          this.raw = txt;
          if (keyCode === 'Backspace') {
            // バックスペース長押し
            if (this._getCaretPosition() === 0 && (txt.length > 0 || diff === 0)) {
              this.fireCombineWithLine(true, false, this.raw);
            }
          }
        }
      }

      updateRaw (e) {
        var editor = this.$.editor;
        var keyCode = e.code;
        var txt = editor.value;
        var diff = Math.abs(this.raw - txt);

        if (!this.arrowLocked) {
          if (keyCode === 'ArrowDown') {
            this._setCaretPosition(this.raw.length);  //
            this.fireupdateLineHighlight(false, true, this._getCaretPosition());
            return;
          }

          if (keyCode === 'ArrowUp') {
            this._setCaretPosition(this.raw.length);  //
            this.fireupdateLineHighlight(true, false, this._getCaretPosition());
            return;
          }
        }
        
        this.raw = txt;
        if (keyCode === 'Backspace') {
          if (this._getCaretPosition() === 0 && (txt.length > 0 || diff === 0)) {
            this.fireCombineWithLine(true, false, this.raw);
          }
        }
      }

      updateRawEnter (e) {
        var editor = this.$.editor;
        var keyCode = e.code;
        var txt = editor.value;

        if (keyCode === 'Enter') {
          // 新たな行の追加要求する
          var caretPos = this._getCaretPosition();
          var tailTxt = txt.substring(caretPos, txt.length);
          var headTxt = txt.substring(0, caretPos);
          this.raw = headTxt;
          this.fireInsertLine(caretPos, tailTxt);
          return;
        }

        this.raw = txt;
      }

      setEditMode (caret=0) {
        var editor = this.$.editor;
        var editorShadow = this.$.editorShadow;
        var h = this.$.line.offsetHeight;

        dawiki.css(this.$.line, { display: 'none' });
        dawiki.css(editor, {
          height: h + 'px',
          display: 'block'
        });
        dawiki.css(editorShadow, {
          height: h + 'px',
          display: 'block'
        });
        editor.focus();
        this._setCaretPosition(caret);
      }

      setViewMode () {
        var editor = this.$.editor;
        var editorShadow = this.$.editorShadow;
        editor.blur();
        dawiki.css(editor, { display: 'none' });
        dawiki.css(editorShadow, { display: 'none' });
        dawiki.css(this.$.line, { display: 'block' });
      }

      /* private methods */
      _getCaretPosition () {
        return this.$.editor.selectionEnd;
      }

      _setCaretPosition (pos=0) {
        var editor = this.$.editor;
        pos = Math.max(pos, 0);
        editor.selectionStart = pos;
        editor.selectionEnd = pos;
      }

      _spans (str) {
        this.$.line.innerHTML = '';
        this.$.line.appendChild(dawiki.spans(str.replace(/\[/g, '').replace(/\]/g, '')));
      }

      _fireupdateLineHighlight (e) {
        this.fireupdateLineHighlight(false, false, this.raw.length);
      }

      /* prop observers */
      _caretChanged (newValue, oldValue) {
        this._setCaretPosition(newValue);
      }

      _bgcolorChanged (newValue, oldValue) {
        this.$.line.style.backgroundColor = newValue;
      }

      _rawChanged (newValue, oldValue) {
        oldValue = oldValue || '';
        var editor = this.$.editor;
        this._spans(newValue);

        // editorShadowに編集中の内容を伝える
        var diffChars = dawiki.diff(oldValue, newValue);
        var ptr = 0;
        //console.info(diffChars);
        // diffChars.forEach(diff => {
        //   if (diff.added) {
        //     var val = diff.value.split('');
        //     val.forEach(c => {
        //       dawiki.append(this.$.editorShadow, `<span class="c">${c}</span>`);
        //     });
        //     ptr += diff.count;
        //   }else if (diff.removed) {
        //     var chars = dawiki.find(this.$.editorShadow, '.c');
        //     for (var i = 0; i < diff.count; i++) {
        //       dawiki.addClass(chars[ptr + i], ['c-rm']);
        //     }
        //     //console.log(chars)
        //     dawiki.remove(this.$.editorShadow, '.c-rm');
        //   }else {
        //     ptr += diff.count;
        //   }
        // });

        this.$.editorShadow.innerHTML = '';
        this.$.editorShadow.appendChild(dawiki.spans(newValue));
        if (editor.value === newValue) return;
        editor.value = newValue;
      }

      /* イベント発火関数 */
      fireCombineWithLine (prev=true, next=false, body='') {
        if ((prev && next) || (!prev && !next)) return;
        this.dispatchEvent(new CustomEvent('combineWithLine', {
          detail: {
            line: this,
            body: body,
            prev: prev,
            next: next
          },
          bubbles: true, 
          composed: true
        }));
      }

      fireInsertLine (caretPos, body) {
        this.dispatchEvent(new CustomEvent('insertLine', {
          detail: {
            line_after: this,
            body: body,
            caret_position: caretPos
          },
          bubbles: true, 
          composed: true
        }));
      }

      fireupdateLineHighlight (prev=false, next=false, caretPosition=0) {
        this.dispatchEvent(new CustomEvent('updateLineHighlight', {
          detail: {
            line : this,
            prev : prev,
            next : next,
            caret: caretPosition
          },
          bubbles: true, 
          composed: true
        }));
      };
    }

    window.customElements.define(DawikiLine.is, DawikiLine);
  </script>
</dom-module>
